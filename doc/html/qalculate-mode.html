<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 4. Calculator Modes</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Qalculate! Manual v2.8.1"><link rel="up" href="index.html" title="Qalculate! Manual v2.8.1"><link rel="prev" href="qalculate-expressions.html" title="Chapter 3. Expressions"><link rel="next" href="qalculate-variables.html" title="Chapter 5. Variables"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Calculator Modes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="qalculate-expressions.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="qalculate-variables.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="qalculate-mode"></a>Chapter 4. Calculator Modes</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="qalculate-mode.html#qalculate-interval-arithmetic">Interval Arithmetic</a></span></dt><dt><span class="sect1"><a href="qalculate-mode.html#qalculate-rpn">The RPN Mode</a></span></dt></dl></div><p>
Qalculate! provides flexible parsing, calculation output and result display. There are several ways in which parsing of expression and display of results can be customized. These modes can generally be changed through the mode menu. The state of each mode can be saved under a name in <span class="guimenu">Mode</span> → <span class="guisubmenu">Meta Modes</span> for quick access. The Preset and Default meta modes are always available and represents the state when Qalculate! is load for the first time and the mode settings automatically loaded at each startup (and by default saved on exit), respectively. Different modes are summarized below.
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Number Bases</span></dt><dd><p>
				Non-decimal bases can be selected for display of numbers in the result. This include regular number bases (binary, octal, hexadecimal, sexagesimal) as well as sexagesimal time format and roman numerals. All number bases between 2 and 36, and base for expression input, can be selected from a dialog window accessed from <span class="guimenu">Mode</span> → <span class="guisubmenu">Number Base</span> → <span class="guimenuitem">Other...</span> or <span class="guimenu">Mode</span> → <span class="guisubmenu">Number Base</span> → <span class="guimenuitem">Select Result and Expression Base...</span>. Note that duodecimal (base 12) numbers use upside down 2 and 3 (or 'X' and 'E'), instead of 'A' and 'B', for the tenth and eleventh digit. The convert number bases dialog (see <a class="xref" href="qalculate-user-interface.html#qalculate-convert-number-bases-dialog" title="Convert Number Bases Dialog">the section called “Convert Number Bases Dialog”</a>) is efficient for simple conversion between common bases.
			</p></dd><dt><span class="term">Numerical Display</span></dt><dd><p>
				These modes mainly control when numbers are displayed exponentially (e.g. <span class="quote">“<span class="quote">2.62E3</span>”</span> which equals <span class="quote">“<span class="quote">2620</span>”</span>). In the default normal mode, numbers are displayed in exponential format if the exponent will be greater than the current precision. In scientific mode the lowest exponent is 3. In simple numerical mode the exponential format is never used and it is always used in purely scientific mode. In the engineering mode, the exponent is always a multiple of three. This is naturally equivalently true for numbers less than one and negative exponents. When the scientific modes are selected in the keypad (not from the menubar), negative exponents are automatically activated and sort minus last deactivated, while normal and simple modes do the opposite.
		</p></dd><dt><span class="term">Indicate Repeating Decimals</span></dt><dd><p>
			If this option is on, Qalculate! will not round infinitely repeating digit sequences, if the digits in the sequence fits the maximum number of decimals. Instead <span class="quote">“<span class="quote">…</span>”</span> will be displayed after the repeated digits and the result indicated as exact (compare <span class="quote">“<span class="quote">9/11 ≈ 0,81818182</span>”</span> with <span class="quote">“<span class="quote">9/11 = 0,81 81…</span>”</span>).
			</p></dd><dt><span class="term">Round Halfway Number To Even</span></dt><dd><p>
			With this option, halfway numbers will be rounded to even instead of upwards (e.g. 2.65 is then rounded to 2.6 instead of 2.7). Note that this behavior is always applied in the <span class="command"><strong>round()</strong></span> function.
		</p></dd><dt><span class="term">Show Ending Zeroes</span></dt><dd><p>
			if this option is on, approximate numbers in the result will be appended with zeroes, so that the number of digits (after preceding zeroes) will equal the precision.
		</p></dd><dt><span class="term">Negative Exponents</span></dt><dd><p>
			If negative exponents is activated, division is shown as a negative power (e.g. <span class="quote">“<span class="quote">x * y^-1</span>”</span> instead of <span class="quote">“<span class="quote">x / y</span>”</span>). 
		</p></dd><dt><span class="term">Sort Minus Last</span></dt><dd><p>
			This option decides if minus signs should be avoided in the first positions of the result expression.
		</p></dd><dt><span class="term">Complex Number Form</span></dt><dd><p>
			Complex number can be displayed in rectangular/cartesian (e.g. <span class="quote">“<span class="quote">5i + 2</span>”</span>), exponential (e.g. <span class="quote">“<span class="quote">5.39 * e^1.19</span>”</span>) or polar form (e.g. <span class="quote">“<span class="quote">5.39 * (cos(1.19) + i * sin(1.19))</span>”</span>). 
		</p></dd><dt><span class="term">Fractional Display</span></dt><dd><p>
			This controls if numbers are displayed in fractional or decimal mode. Decimal mode displays numbers as usually expected (<span class="quote">“<span class="quote">6/4 = 1.5</span>”</span>), combined displays a whole number and a fraction (<span class="quote">“<span class="quote">6/4 = 1 1/2</span>”</span>) and fractional only displays as fraction (<span class="quote">“<span class="quote">6/4 = 3/2</span>”</span>).
		</p></dd><dt><span class="term">Unit Display</span></dt><dd><p>
			The automatic use of prefixes for units in results can be toggled on and off. By default prefixes are only used for a selection of units (mainly standard SI and CGS units), but this can be changed to also include currencies or all other units. By default prefixes representing a power of ten not dividable by three (centi, deci, deca and hekto) are not used and need to be enabled. If denominator prefixes are not explicitly enabled, prefixes will only be set for the numerator in a fractional unit expression (e.g. <span class="quote">“<span class="quote">1 Mg/m</span>”</span> or <span class="quote">“<span class="quote">1 kg/mm</span>”</span>), unless there is no unit in the numerator. The place units separately alternative controls the display of unit expressions in result. If it is enabled (default) units will be displayed separate from other parts of the expression at the end (compare <span class="quote">“<span class="quote">(5x*m)/(y*s)</span>”</span> and <span class="quote">“<span class="quote">5x/y m/s</span>”</span>).
		</p><p>
			Units can be automatically converted to base units or the optimal units in results. Optimal conversion means that the number of units in the result is reduced to as few units as possible. Only SI units are used for conversion. If <span class="guimenuitem">Convert to Optimal SI unit</span> is activated, non-SI units are converted to SI units, even if equally or less optimal than the original unit(s). In optimal unit mode, currencies are converted to the local currency, unless deactivated in the preferences dialog. Mixed units conversion allows certain units, such as time units and many imperial/U.S. customary units, to be converted to a combination of appropriate units, e.g. <span class="quote">“<span class="quote">60.2 minutes = 1 hour to 12 seconds</span>”</span>.
		</p></dd><dt><span class="term">Abbreviate Names</span></dt><dd><p>
			The display of unit, prefix, variable and function names can be controlled by selecting to display abbreviations or full length names (e.g. <span class="quote">“<span class="quote">5 cm</span>”</span> or <span class="quote">“<span class="quote">5 centimeters</span>”</span>). Both abbreviations and long names can however always be entered in expressions.
		</p></dd><dt><span class="term">Approximation</span></dt><dd><p>
			When always exact mode is on, the calculation will not go further than what can be calculated exactly (e.g. <span class="quote">“<span class="quote">sqrt(2+3) = sqrt(5)</span>”</span>). The  default <span class="quote">“<span class="quote">Try Exact</span>”</span> mode, will calculate the result exact as far as possible and then approximately. Approximate mode will directly calculate a approximate result, thus being a bit faster but giving a less correct approximate indication (<span class="quote">“<span class="quote">sin(pi/2)</span>”</span> return approximately one instead of exactly one). If the interval arithmetic mode is activated the precision of the final result is guaranteed by calculating an interval for every approximate value (See <a class="xref" href="qalculate-mode.html#qalculate-interval-arithmetic" title="Interval Arithmetic">the section called “Interval Arithmetic”</a>).
		</p></dd><dt><span class="term">Assumptions</span></dt><dd><p>
			This controls the default assumptions for unknown variables without explicitly defined assumptions. See <a class="xref" href="qalculate-variables.html" title="Chapter 5. Variables">Chapter 5, <i>Variables</i></a>.
			The assume denominators non-zero alternative makes it possible to avoid the situation where expressions such as <span class="quote">“<span class="quote">(x-1)/(x-1)</span>”</span> can not be further simplified because the denominator might be zero (if x equals 1). With this alternative activated the example can be reduced to 1.
		</p></dd><dt><span class="term">Parsing Mode</span></dt><dd><p>
			These options controls how expressions are interpreted. There are three main modes, which mainly controls if implicit multiplication is handled differently from explicit multiplication and if spaces are taken into account or not.  See <a class="xref" href="qalculate-expressions.html#qalculate-implicit-multiplication" title="Implicit Multiplication and Parsing Modes">the section called “Implicit Multiplication and Parsing Modes”</a>.
			If the read precsion option is activated, decimal numbers are intrepeted as approximate with precision equal to the number of digits (e.g. <span class="quote">“<span class="quote">1.1 * 1.1 ≈ 1.2</span>”</span>). If interval arithmetic is enabled, decimal numbers are interpreted as an interval between the numbers that are normally rounded to the entered number (e.g. <span class="quote">“<span class="quote">1.1 = 1.1±0.05</span>”</span>).
		</p></dd><dt><span class="term">Precision</span></dt><dd><p>
			Precision specifies the default number of significant digits displayed and determines the precision used for approximate calculations. The internal precision is higher than the one specified, but will nevertheless not completely protect against loss of significance/catastrophic cancellation (and you will not be alterted unless interval arithmetic is activated). If the read precision option is turned on, input numbers with decimals will be interpreted as approximate with a precision equal to the number of digits (e.g. <span class="quote">“<span class="quote">2.50 + 3.4567 = 5.96</span>”</span>).
		</p></dd><dt><span class="term">Decimals</span></dt><dd><p>
			In the decimals dialog, the number of decimals displayed can be controlled. This includes minimal (will fill out with zeroes) and maximal number of decimals (will round numbers).
		</p></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="qalculate-interval-arithmetic"></a>Interval Arithmetic</h2></div></div></div><p>
Interval arithmetic can be used explicitly to perform calculations on an interval (defined using the <span class="command"><strong>interval()</strong></span> function or <span class="quote">“<span class="quote">±</span>”</span> notation), or implicitly for all approximate calculations to keep track of precision changes. The latter is especially useful for calculation using numbers with few implicit digits, in combination with the <span class="quote">“<span class="quote">read precision</span>”</span> mode, for calculation with approximate physical constants, which are defined as an interval using standard uncertainty values (if interval arithmetic is activated), or to gracefully handle for example catastrophic cancellation (in subtracting two nearly equal numbers). Interval arithmetic can be (de)activated using <span class="guimenu">Mode</span>+<span class="guimenu">Approximation</span> → <span class="guimenuitem">Interval Arithmetic</span> or from the corresponding menu on the keypad.
</p><p>
The main issue with interval arithmetic is handling of dependent values. The simple expression <span class="quote">“<span class="quote">2 * interval(1, 2) - pi * interval(1, 2)</span>”</span> gives as result <span class="quote">“<span class="quote">interval(-4.283, 0.858)</span>”</span>, which is correct if the two intervals in the expression are unrelated. If they on the instead refers to the same measurement the true result should be <span class="quote">“<span class="quote">-interval(1.141, 2.283)</span>”</span>, but Qalculate! has no way of knowing this. There are some ways the circumvent this issue <span class="quote">“<span class="quote">interval(1, 2) * (2 - pi)</span>”</span> returns the correct interval. Qalculate! is in most cases able to handle this automatically with variables and function arguments for most differentiable functions.
</p><p>
Some non-invertible functions (including bessel and airy functions) are not properly support and only the function value for the end values of the interval are calculated. Trigonometric functions should however give correct intervals for real and imaginary numbers, but will in some cases for complex numbers with both a real and imaginary part return a too wide interval.
</p><p>
Generally, the resulting interval will be guaranteed to include the true interval, but may often for non-trivial expression (especially involving complex numbers) return an interval that is to wide.
</p><p>
For implicit interval arithmetic the result is by default shown as an ordinary number with the number of significant digits determined by the width of the interval(<span class="quote">“<span class="quote">interval(2.075, 2.15) = 2.1</span>”</span>), unless the interval is too wide. If the <span class="command"><strong>interval()</strong></span> has been used in the expression the result is by default displayed as an interval, and if <span class="quote">“<span class="quote">±</span>”</span> notation has been used, it will also be used in the result. The default behaviour can be changed from<span class="guimenu">Mode</span>+<span class="guimenu">Interval Display</span>. The midpoint alternative displays the value halfway between the lower and upper limit of the interval (<span class="quote">“<span class="quote">interval(2.075, 2.15) = 2.1125</span>”</span>). Note that, for the plus/minus notation, the same midpoint (not the result for the midpoint of intervals in the expression) is displayed in front of the plus/minus symbol.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="qalculate-rpn"></a>The RPN Mode</h2></div></div></div><p>
The Reverse Polish Notation mode can be activated from <span class="guimenu">Mode</span> → <span class="guimenuitem">RPN Mode</span>, <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>R</strong></span> or from the context menu of the expression entry. For details about what Reverse Polish Notation is and how it generally works, see for example the <a class="ulink" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_top">RPN article at Wikipedia</a>.
</p><p>
Central to the RPN mode is the stack, a list of registers/values that is operated on by functions and operators. The stack has a variable number of registers which can hold an unlimited number of values. The stack size is dynamically changed when a new value is added and the first value on the stack is shown in the result display. Mathematical operators such as plus and minus then operates on the first two, last added, values on the stack. The second value is changed with input from the first value. For example, the minus operator subtracts the first value from the second.
</p><p>
For example, <span class="command"><strong>5 ENTER 3 + 2 /</strong></span> adds 5 to the stack, then adds 3 to the stack and moves 5 down a step and adds 3 to 5. The first value, 3, is removed from the stack and the value left is 8. Then 2 is added to the stack and 8 is divided by 2, resulting in 4. This would in a single expression with non-RPN (infix) syntax be entered as <span class="quote">“<span class="quote">(5+3)/2</span>”</span>.
</p><p>
Functions operate on the top values of the stack. Functions which require multiply arguments, fill the arguments in reversed order from the top (e.g. <span class="command"><strong>5 ENTER 2 ENTER rem</strong></span> equals <span class="quote">“<span class="quote">rem(5, 2)</span>”</span>). Functions with a vector argument uses all stack regsters (unless the top value is a vector). This is quite useful for statistical functions (e.g. <span class="command"><strong>5 ENTER 2 ENTER 3 ENTER 4 ENTER harmmean</strong></span> calculates the harmonic mean of 5, 2, 3, and 4 and leaves the result, 3.1169, as the only value on the stack).
</p><p>
When the RPN stack is enabled, full expressions can still be entered (you can add e.g. <span class="quote">“<span class="quote">5x+3+23+sin(2)</span>”</span> directly to the stack). The buttons on the keypad do not insert operators and functions in the expression entry, but instead applies them to the stack. This is also true for the keys on the keyboard, unless deactivated in the preferences (<span class="guimenu">Edit</span> → <span class="guimenuitem">Preferences</span>). <span class="keycap"><strong>Enter</strong></span> calculates the current expressions and adds it to the stack (calculated mathematical expressions are automatically added to the stack when the RPN stack is enabled). If the expression entry is not empty when applying an operator or function to the stack, the expression is first calculated and added to the stack. All keys on the main part of the keyboard add the corresponding characters in the expression entry, unless the <span class="guilabel">Use only keypad keys for RPN</span> option is deactivated from the preferences dialog. To apply the raise operator '^' to the stack, without clicking the keypad button with the mouse, use the <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>* (keypad)</strong></span> shortcut. If the expression only contains an operator or a single function without arguments, the operator/function is applied to the stack.
</p><div class="figure"><a name="qalculate-FIG-rpn-mode"></a><p class="title"><b>Figure 4.1. RPN Mode</b></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="485"><tr><td><img src="figures/rpn-mode.png" width="485" alt="RPN Mode"></td></tr></table></div></div></div></div><br class="figure-break"><p>
The RPN mode adds a third page to the main window, for display and manipulation of the values on the stack. This shows a list of values on the stack, with the last added value on the top. On the right are buttons for manipulation of the stack. The buttons move the selected value up or down, move it to the top, edit it, or removes it, in order. If no stack row is selected, the up and down buttons rotates the stack, the swap button swaps the places of the first and second value and the copy and delete buttons acts on the the top value of the stack. The last button removes all values from the stack. On the left are buttons for applying mathematical operations to the stack. These works the same as buttons on the separate keypad. Changes in the display of results only affects the first value on the stack.
</p><p>
Reverse Polish Notation can also be used directly in expression. This can be activated or deactivated separately from the RPN stack (<span class="guimenu">Mode</span> → <span class="guimenuitem">Parsing Mode</span> → <span class="guimenuitem">RPN Syntax</span>). When using RPN syntax, a temporary stack, separate from the previously mentioned stack, is created from the contents of each mathematical expression entered. To calculate <span class="quote">“<span class="quote">(5+3)/2</span>”</span>, as in the example above, with RPN syntax you should enter the expression <span class="quote">“<span class="quote">5 3 + 2 /</span>”</span>. Instead of actually pressing enter on the keyboard, each separate value on the stack is separated by a blank space. The RPN syntax only supports functions that require exactly one argument.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="qalculate-expressions.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="qalculate-variables.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Expressions </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. Variables</td></tr></table></div></body></html>
